/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "IfxPort.h"
#include "IfxStm.h"
#include "IfxPort_regdef.h"

#include "driver/asclin.h"
#include "driver/can.h"
#include "driver/stm.h"
#include "data.h"

IfxCpu_syncEvent g_cpuSyncEvent = 0;

/* 글로벌 핸들 */
IfxMultican_Can        g_can;         // CAN 모듈 핸들
IfxMultican_Can_Node   g_canNode;     // CAN 노드 핸들
IfxMultican_Can_MsgObj g_txMsgObj;    // 송신 메시지 오브젝트
IfxMultican_Can_MsgObj g_rxMsgObj;    // 수신 메시지 오브젝트

/* 송신 메시지 */
IfxMultican_Message g_txMsg;
/* 수신 메시지 */
IfxMultican_Message g_rxMsg;

IfxMultican_Status g_status;  // CAN 상태


#define LEDL                        &MODULE_P02,6               //LED connected to Port 00, Pin 5
#define LEDR                        &MODULE_P02,7               //LED connected to Port 00, Pin 6



void ws2812_send_byte(Ifx_P *port, uint8 pinIndex, uint8 data) __attribute__((section(".otaSection0"))) 
{
    for (int i = 7; i >= 0; i--) {
        if (data & (1 << i)) {
            // 1비트 전송: High 0.8us + Low 0.45us
            IfxPort_setPinHigh(port, pinIndex);
            waitwaitns(70);
            IfxPort_setPinLow(port, pinIndex);
            
            waitwaitns(12);
        } else {
            // 0비트 전송: High 0.4us + Low 0.85us
            IfxPort_setPinHigh(port, pinIndex);
            waitwaitns(12);
            IfxPort_setPinLow(port, pinIndex);
            waitwaitns(70);
        }
    }
    // 18 : 500
    // 80 : 1us
}

void ws2812_send_color(Ifx_P *port, uint8 pinIndex, uint8 g, uint8 r, uint8 b) __attribute__((section(".otaSection0"))) 
{
    IfxPort_setPinLow(port, pinIndex);
    //waitwaitns(3000);
    //waitwaitns(4500);
    waitwaitns(4300);
    //waitwaitns(1000);

    ws2812_send_byte(port, pinIndex, g);
    ws2812_send_byte(port, pinIndex, r);
    ws2812_send_byte(port, pinIndex, b);
}


void myfunc() __attribute__((section(".otaSection0")))       // 현재 사용 섹션
{
    volatile int i = 0;
    volatile int j = 0;
    IfxPort_setPinModeOutput(LEDR, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LEDL, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(LEDL);
    IfxPort_setPinLow(LEDR);
    waitwaitns(4500);

    for(i = 0; i < 8;i++){
        ws2812_send_color(LEDR, 0x00, 0x00, 0x00);
    }
    for(i = 0; i < 8;i++){
        ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  
    }

    int num = 2;
    while(num--) {
        for (i = 0; i < 8; i++)
        {
            for (j = 0; j < 8; j++) // 한 세트 8개
            {
                if (i <= j) {
                    ws2812_send_color(LEDR, 0x00, 0x00, 0x00);  // off
                }
                else {
                    ws2812_send_color(LEDR, 0x40, 0x40, 0x40);  // on
                }
            }

            for (j = 0; j < 8; j++) // 한 세트 8개
            {
                if (i <= j) {
                    ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  // off
                }
                else {
                    ws2812_send_color(LEDL, 0x40, 0x40, 0x40);  // on
                }
            }
            for(volatile int t=0;t<1500000;t++);
        }

        for (i = 0; i < 8; i++)
        {
            for (j = 0; j < 8; j++) // 한 세트 8개
            {
                if (i >= j) {
                    ws2812_send_color(LEDR, 0x00, 0x00, 0x00);  // off
                }
                else {
                    ws2812_send_color(LEDR, 0x40, 0x40, 0x40);  // on
                }
            }

            for (j = 0; j < 8; j++) // 한 세트 8개
            {
                if (i >= j) {
                    ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  // off
                }
                else {
                    ws2812_send_color(LEDL, 0x40, 0x40, 0x40);  // on
                }
            }
            for(volatile int t=0;t<1500000;t++);
        }
    }
}



void adb(uint8 posr, uint8 posl)
{
    // 전체 클리어
    for(int i = 0; i < 8;i++){
        ws2812_send_color(LEDR, 0x00, 0x00, 0x00);
    }
    for(int i = 0; i < 8;i++){
        ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  
    }


    // 예: 켜고 싶은 LED 비트 위치 설정 (ex: 0x18 → 3번, 4번 on)
    for (int i = 0; i < 8; i++)
    {
        if (posr & (1 << (7 - i)))  // MSB부터 확인
        {
            ws2812_send_color(LEDR, 0x40, 0x40, 0x40);  // on
        }
        else
        {
            ws2812_send_color(LEDR, 0x00, 0x00, 0x00);  // off
        }
    }

    for (int i = 0; i < 8; i++)
    {
        if (posl & (1 << (7 - i)))  // MSB부터 확인
        {
            //ws2812_send_color(LEDL, 0x40, 0x40, 0x40);  // on
            ws2812_send_color(LEDL, 0x40, 0x40, 0x40);  // on
        }
        else
        {
            //ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  // off
            ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  // off
        }
    }
}

void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
        
    initShellInterface();
    initCan();

    Driver_Stm_Init();


//     volatile uint32 firmware_data[32]=
// {
//         0x00DA0820,0x2D3CAF74,0xFF004091,0x0B00FFD9,0x1F8601DA,0x00DAF16C,0x043C0178,0x1FC20158,
//         0x01580178,0x04B4003B,0x0004C09B,0x7FF80F3F,0xFF004091,0x0B00FFD9,0xF000107B,0xF16C1F86,
//         0x017800DA,0x0158043C,0x01781FC2,0x003B0158,0xC09B04B4,0x0F3F0004,0xAF547FF8,0xAF741FC2,
//         0x5FBFAF54,0x90007FD3,0,0,0,0,0,0
// //         0,0,0,0,0,0,0,0,
// //         0,0,0,0,0,0,0,0,
// //         0,0,0,0,0,0,0,0,
// //         0,0,0,0,0,0,0,0
// };


#define waitingtime 500000 //1000000 //1000000
    g_txMsg.id = 0x10;
    g_txMsg.lengthCode = 8;
    g_txMsg.data[0] = (uint32)(1);
    g_txMsg.data[1] = (uint32)(0x801000BC);
    g_status = sendCanMessage();  // 메시지 전송
    print("%d\n\r", g_status);
    for(volatile int i=0;i<waitingtime;i++);

    g_txMsg.id = 0x11;
    g_txMsg.lengthCode = 8;
    for(int i=0; i < size; i+=2){
        g_txMsg.data[0] = data_ota1[i];
        g_txMsg.data[1] = data_ota1[i+1];
        g_status = sendCanMessage();  // 메시지 전송
        print("%d\n\r", g_status);
        for(volatile int i=0;i<waitingtime;i++);
    }

    g_txMsg.id = 0x12;
    g_txMsg.lengthCode = 8;
    g_txMsg.data[0] = (uint32)(3);
    g_txMsg.data[1] = (uint32)(4);
    g_status = sendCanMessage();  // 메시지 전송
    for(volatile int i=0;i<waitingtime;i++);

    print("%d\n\r", g_status);





// g_txMsg.id = 0x154;
// g_txMsg.lengthCode = 8;
// g_txMsg.data[0] = (uint32)(0x01422400);
// g_txMsg.data[1] = (uint32)(0x801000BC);
// g_status = sendCanMessage();  // 메시지 전송




    uint8 rainbow[][3] = {
    {0xFF, 0x00, 0x00}, // Green
    {0x80, 0x80, 0x00}, // Lime-yellow
    {0x00, 0xFF, 0x00}, // Red
    {0x00, 0x80, 0x80}, // Cyan
    {0x00, 0x00, 0xFF}, // Blue
    {0x80, 0x00, 0x80}, // Purple
    {0xFF, 0x00, 0x80}, // Pinkish
    {0x00, 0x00, 0x00}  // OFF
    };

    // ws2812_send_color(0xFF, 0x00, 0x00);  // 빨강
    // ws2812_send_color(0x00, 0xFF, 0x00);  // 초록
    // ws2812_send_color(0x00, 0x00, 0xFF);  // 파랑
    // ws2812_send_color(0xFF, 0xFF, 0x00);  // 노랑
    // ws2812_send_color(0x00, 0xFF, 0xFF);  // 시안
    // ws2812_send_color(0xFF, 0x00, 0xFF);  // 마젠타
    // ws2812_send_color(0xFF, 0x80, 0x00);  // 주황
    // ws2812_send_color(0x80, 0x00, 0xFF);  // 보라

    IfxPort_setPinModeOutput(LEDR, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LEDL, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(LEDL);
    IfxPort_setPinLow(LEDR);
    waitwaitns(4500);

    for(int i = 0; i < 8;i++){
        ws2812_send_color(LEDR, 0x00, 0x00, 0x00);
    }
    for(int i = 0; i < 8;i++){
        ws2812_send_color(LEDL, 0x00, 0x00, 0x00);  
    }


//    for(int i=0;i<size;i++) {
//        if(data3[i] != data2[i]) {
//            print("? %d\n\r", i);
//        }
//    }

    while(1)
    {

        //myfunc();


        adb(0x42, 0x1F);

        //return;






        //     // 소등: 오른쪽 → 왼쪽 (7 → 0)
        // for (int i = 0; i < 8; i++)
        // {
        //     for (int j = 0; j < 8; j++)
        //     {
        //         if (j < (8 - i - 1))
        //             ws2812_send_color(0x00, 0x00, 0xFF);  // 파란색 유지
        //         else
        //             ws2812_send_color(0x00, 0x00, 0x00);  // 꺼짐
        //     }

        //     for(volatile int i=0;i<1500000;i++);
        // }

    }
}
